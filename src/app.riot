<app>
  <section>
    <ptrack
      each={ input in state.articles }
      input={ input }
      onStreamReady={ onStreamReady } ></ptrack> 
  </section>
  <footer>
      <button
        name="play"
        onclick={ play }
        disabled={ state.disabled }>Play
      </button>
      <button
        name="stop"
        onclick={ pause }>Stop
      </button>
  </footer>
  <style>
    :host {
      --section-width: 100%;
    }
    @media (min-width: 360px) {
      :host {
        --section-width: 100%;
      }
    }
    /* For tablet devices */
    @media (min-width: 720px) {
      :host {
      }
    }

    @media (min-width: 1024px) {
      :host {
        --section-width: 80%;
      }
      section {
        margin: auto;
      }
    }

    section {
      width: var(--section-width);
    }
    footer {
      position: fixed;
      bottom: 0;
    }
  </style>
  <script>
    import Nanobar from 'nanobar';
    import PTrack from './ptrack.riot';
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
/**
    state-change: when audio controller changes state (e.g. from pause to play). Possible values: 'playing', 'paused', 'loading', 'ended', 'error' or 'dead'
    play: when play method is called
    play-start: when playback actually starts, the first time
    play-resume: when playback starts, the second time onwards
    play-rejection: if a play request is rejected by the browser
    pause: when playback is paused
    finish: when sound is finished
    seek: when seek method is called
    seeked: when a seek completes
    seek-rejection: when a seek is rejected for some reason
    geo_blocked: when there's no available streams for a sound, as it is not allowed to be played in the user's territory.
    buffering_start: when buffering starts
    buffering_end: when buffering stops
    audio_error: when an error occurs
    time: when playback position is updated
    no_streams: when we failed fetching stream information
    no_protocol: when no supported protocol could be found
    no_connection: when we failed to connect to an endpoint due to missing transport or request timeout**/
    export default {
      state: {
        progress: null,
        articles: [],
        streams: new Map(),
        current: null,
        playlist: [],
      },
      components: {
        PTrack
      },
      onBeforeMount(props, state) {
        SC.initialize({
          client_id: this.props.client_id
        });
        state.articles = props.tracks
          .filter( t => [ 520565400, 555134337 ].indexOf(parseInt(t.id)) === -1)
          .map( t => ({
            uri: `tracks/${t.id}`,
            title: t.title,
            username: t.user.username,
            cover: t.artwork_url.replace('large', 't500x500'),
          }));
      },
      onMounted(props, state) {
        state.progress = new Nanobar();
      },
      onUpdated() {
        console.log('updated');
      },
      onStreamReady(evt) {
        const { uri, player, err } = evt.detail;
        if (err) {
          const i = this.state.articles.findIndex( a => a.uri === uri );
          this.state.articles = this.state.articles.splice(i, 1);
        } else {
          this.state.streams.set(uri, player);
        }

        const p = this.state.streams.size / this.state.articles.length;
        this.state.progress.go(Math.floor(p * 100));
      },
      play() {
        // shuffle the playlist
        if (this.state.playlist.length === 0) {
          this.state.playlist = shuffle(this.state.articles.map( a => a.uri));
        }
        // scroll to article
        const uri = this.state.playlist.pop();
        window.location.hash = uri;

        const stream = this.state.streams.get(uri);
        stream.on('play-start', () => {
          setTimeout(() => this.play(), 3000);
        });
        stream.on('time', console.log);
        //attachHandlers(stream, this.state.progress);
        stream.play();

        this.state.current = { uri, stream };
      },
      stop() {
        if (this.state.current) {
          this.state.current.stream.pause();
        }
      }
    };
  </script>
</app>
